import * as path from 'path';

import {stripIndent} from 'common-tags';
import {createProjectPlugin, Runtime, TargetRuntime} from '@quilted/sewing-kit';
import type {
  App,
  WaterfallHook,
  WaterfallHookWithDefault,
} from '@quilted/sewing-kit';
import type {ModuleFormat} from 'rollup';

import {
  MAGIC_MODULE_APP_ASSET_LOADER,
  MAGIC_MODULE_APP_COMPONENT,
  MAGIC_MODULE_HTTP_HANDLER,
} from '../constants';

import {STEP_NAME} from './app-build';
import type {EnvironmentOptions} from './magic-module-env';

import {preloadAllGlobal} from './rollup/preload-all';

export interface AppServerOptions {
  /**
   * The relative path to the module you want to use as the
   * entry for your app server. When provided, this completely
   * overwrites the default server content.
   *
   * @example './server'
   */
  entry: string;

  /**
   * Whether this server code uses the `http-handlers` library to
   * define itself in a generic way, which can be adapted to a variety
   * of environments. By default, this is `true`, and when `true`,
   * the `entry` you specified must export an `HttpHandler` object as
   * its default export. When set to `false`, the app server will be built
   * as a basic server-side JavaScript project, without the special
   * `http-handlers` adaptor.
   *
   * @default true
   */
  httpHandler?: boolean;

  /**
   * Whether the automatic server will serve assets for the browser build.
   * If this is `true`, you must ensure that your assets are stored in an
   * `assets` directory that is a sibling to the `server` directory that
   * will contain your server files. This is done automatically for you
   * with the default configuration applied by Quilt.
   *
   * @default true
   */
  serveAssets?: boolean;

  /**
   * Controls how the app server exposes environment variables.
   */
  env?: EnvironmentOptions;
}

export interface AppServerBuildOptions {
  /**
   * Indicates that the app server build is being generated by Quilt.
   */
  quiltAppServer: boolean;
}

export interface AppServerHooks {
  /**
   * The module format that will be used for the application server. By
   * default, this is set to `module`, which generates native ES module
   * outputs.
   */
  quiltAppServerOutputFormat: WaterfallHook<ModuleFormat>;

  /**
   * Whether the automatic server will serve assets for the browser build.
   * If this is `true`, you must ensure that your assets are stored in an
   * `assets` directory that is a sibling to the `server` directory that
   * will contain your server files. This is done automatically for you
   * with the default configuration applied by Quilt.
   */
  quiltAppServerServeAssets: WaterfallHookWithDefault<boolean>;
}

declare module '@quilted/sewing-kit' {
  interface BuildAppOptions extends AppServerBuildOptions {}
  interface BuildAppConfigurationHooks extends AppServerHooks {}
}

const MAGIC_CUSTOM_SERVER_ENTRY_MODULE = '__quilt__/CustomAppServer';

export function appServer(options?: AppServerOptions) {
  const entry = options?.entry;
  const httpHandler = options?.httpHandler ?? true;
  const serveAssets = options?.serveAssets ?? true;
  const inlineEnv = options?.env?.inline;

  return createProjectPlugin<App>({
    name: 'Quilt.App.Server',
    build({project, hooks, configure, run}) {
      hooks<AppServerHooks>(({waterfall}) => ({
        quiltAppServerOutputFormat: waterfall(),
        quiltAppServerServeAssets: waterfall({default: serveAssets}),
      }));

      configure(
        (
          {
            runtime,
            outputDirectory,
            rollupInput,
            rollupPlugins,
            rollupOutputs,
            quiltAppServerHost,
            quiltAppServerPort,
            quiltAppServerEntryContent,
            quiltAppServerOutputFormat,
            quiltAppServerServeAssets,
            quiltHttpHandlerHost,
            quiltHttpHandlerPort,
            quiltHttpHandlerContent,
            quiltHttpHandlerRuntimeContent,
            quiltAsyncPreload,
            quiltAsyncManifest,
            quiltAssetBaseUrl,
            quiltInlineEnvironmentVariables,
            quiltRuntimeEnvironmentVariables,
          },
          {quiltAppServer = false},
        ) => {
          if (!quiltAppServer) return;

          if (inlineEnv != null && inlineEnv.length > 0) {
            quiltInlineEnvironmentVariables?.((variables) =>
              Array.from(new Set([...variables, ...inlineEnv])),
            );
          }

          quiltRuntimeEnvironmentVariables?.(
            (runtime) => runtime ?? 'process.env',
          );

          runtime(() => new TargetRuntime([Runtime.Node]));

          const content = entry
            ? httpHandler
              ? stripIndent`
                  export {default} from ${JSON.stringify(
                    project.fs.resolvePath(entry),
                  )};
                `
              : stripIndent`
                  import ${JSON.stringify(project.fs.resolvePath(entry))};
                `
            : stripIndent`
                import App from ${JSON.stringify(MAGIC_MODULE_APP_COMPONENT)};
                import assets from ${JSON.stringify(
                  MAGIC_MODULE_APP_ASSET_LOADER,
                )};
                import {createServerRenderingHttpHandler} from '@quilted/quilt/server';

                export default createServerRenderingHttpHandler(App, {
                  assets,
                });
              `;

          quiltAsyncPreload?.(() => false);
          quiltAsyncManifest?.(() => false);

          rollupPlugins?.(async (plugins) => {
            const {cssRollupPlugin} = await import('./rollup/css');

            plugins.push(cssRollupPlugin({extract: false}));

            plugins.unshift({
              name: '@quilted/magic-module/asset-manifest',
              async resolveId(id) {
                if (id === MAGIC_MODULE_APP_ASSET_LOADER) return id;
                return null;
              },
              async load(source) {
                if (source !== MAGIC_MODULE_APP_ASSET_LOADER) return null;

                const manifestFiles = await project.fs.glob('manifest*.json', {
                  cwd: project.fs.buildPath('manifests'),
                  onlyFiles: true,
                });

                const manifests = (
                  await Promise.all(
                    manifestFiles.map(async (manifestFile) => {
                      const manifestString = await project.fs.read(
                        manifestFile,
                      );

                      return JSON.parse(manifestString);
                    }),
                  )
                ).sort(
                  (manifestA, manifestB) =>
                    (manifestA.metadata.priority ?? 0) -
                    (manifestB.metadata.priority ?? 0),
                );

                return stripIndent`
                  import {createAssetLoader} from '@quilted/quilt/server';

                  const manifests = JSON.parse(${JSON.stringify(
                    JSON.stringify(manifests),
                  )});

                  for (const manifest of manifests) {
                    manifest.metadata.browsers =
                      manifest.metadata.browsers
                        ? new RegExp(manifest.metadata.browsers)
                        : undefined;
                  }

                  // The default manifest is the last one, since it has the widest browser support.
                  const defaultManifest = manifests[manifests.length - 1];

                  const assetLoader = createAssetLoader({
                    getManifest({userAgent}) {
                      // If there is no user agent, use the default manifest.
                      if (typeof userAgent !== 'string') return defaultManifest;

                      for (const manifest of manifests) {
                        if (manifest.metadata.browsers instanceof RegExp && manifest.metadata.browsers.test(userAgent)) {
                          return manifest;
                        }
                      }

                      return defaultManifest;
                    },
                  });

                  export default assetLoader;
                `;
              },
            });

            if (!httpHandler) {
              plugins.push({
                name: '@quilted/magic-app-server-custom-entry',
                resolveId(id) {
                  if (id === MAGIC_CUSTOM_SERVER_ENTRY_MODULE) {
                    // We resolve to a path within the project’s directory
                    // so that it can use the app’s node_modules.
                    return {
                      id: project.fs.resolvePath(id),
                      moduleSideEffects: 'no-treeshake',
                    };
                  }

                  return null;
                },
                load(source) {
                  if (
                    source !==
                    project.fs.resolvePath(MAGIC_CUSTOM_SERVER_ENTRY_MODULE)
                  ) {
                    return null;
                  }

                  return content;
                },
              });
            }

            plugins.push(preloadAllGlobal());

            return plugins;
          });

          rollupOutputs?.(async (outputs) => {
            const [format, outputRoot] = await Promise.all([
              quiltAppServerOutputFormat!.run('module'),
              outputDirectory.run(project.fs.buildPath()),
            ]);

            outputs.push({
              format,
              entryFileNames: 'index.js',
              dir: path.join(outputRoot, 'server'),
            });

            return outputs;
          });

          if (httpHandler) {
            quiltHttpHandlerHost?.(async () =>
              quiltAppServerHost!.run(undefined),
            );

            quiltHttpHandlerPort?.(async () =>
              quiltAppServerPort!.run(undefined),
            );

            quiltHttpHandlerContent?.(
              async () => await quiltAppServerEntryContent!.run(content),
            );

            quiltHttpHandlerRuntimeContent?.(async (content) => {
              if (content) return content;

              const [port, host, serveAssets, format, assetBaseUrl] =
                await Promise.all([
                  quiltHttpHandlerPort!.run(undefined),
                  quiltHttpHandlerHost!.run(undefined),
                  quiltAppServerServeAssets!.run(),
                  quiltAppServerOutputFormat!.run('module'),
                  quiltAssetBaseUrl!.run(),
                ]);

              return stripIndent`
                ${serveAssets ? `import * as path from 'path';` : ''}
                ${
                  serveAssets && format === 'module'
                    ? `import {fileURLToPath} from 'url';`
                    : ''
                }
                import {createServer} from 'http';

                import httpHandler from ${JSON.stringify(
                  MAGIC_MODULE_HTTP_HANDLER,
                )};
      
                import {createHttpRequestListener${
                  serveAssets ? ', serveStatic' : ''
                }} from '@quilted/quilt/http-handlers/node';

                const port = ${port ?? 'Number.parseInt(process.env.PORT, 10)'};
                const host = ${
                  host ? JSON.stringify(host) : 'process.env.HOST'
                };

                ${
                  serveAssets
                    ? `const dirname = ${
                        format === 'module'
                          ? 'path.dirname(fileURLToPath(import.meta.url))'
                          : '__dirname'
                      };\nconst serve = serveStatic(path.resolve(dirname, '../assets'), {
                        baseUrl: ${JSON.stringify(assetBaseUrl)},
                      });`
                    : ''
                }
                const listener = createHttpRequestListener(httpHandler);
              
                createServer(async (request, response) => {
                  ${
                    serveAssets
                      ? `if (request.url.startsWith(${JSON.stringify(
                          assetBaseUrl,
                        )})) return serve(request, response);`
                      : ''
                  }

                  await listener(request, response);
                }).listen(port, host);
              `;
            });
          } else {
            rollupInput?.(() => [MAGIC_CUSTOM_SERVER_ENTRY_MODULE]);
          }
        },
      );

      run((step, {configuration}) =>
        step({
          name: 'Quilt.App.Server',
          label: `Build automatic server for app ${project.name}`,
          needs: (step) => {
            return {
              need: step.target === project && step.name === STEP_NAME,
              allowSkip: true,
            };
          },
          async run() {
            const [configure, {buildWithRollup}] = await Promise.all([
              configuration({
                quiltAppServer: true,
                quiltHttpHandler: httpHandler,
              }),
              import('@quilted/sewing-kit-rollup'),
            ]);

            await buildWithRollup(project, configure);
          },
        }),
      );
    },
  });
}
