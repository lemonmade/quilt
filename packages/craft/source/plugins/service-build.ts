import * as path from 'path';
import {rm} from 'fs/promises';

import type {ModuleFormat} from 'rollup';

import {createProjectPlugin} from '../kit';
import type {WaterfallHook} from '../kit';

import {addRollupNodeBundleInclusion, RollupNodeBundle} from '../tools/rollup';

import type {EnvironmentOptions} from './magic-module-env';

export interface ServiceBuildHooks {
  /**
   * The module format that will be used for the application server. By
   * default, this is set to `module`, which generates native ES module
   * outputs.
   */
  quiltServiceOutputFormat: WaterfallHook<ModuleFormat>;
}

declare module '@quilted/sewing-kit' {
  interface BuildProjectOptions {
    /**
     * Indicates that the base build is being generated by `quilt`.
     */
    quiltService: boolean;
  }

  interface BuildProjectConfigurationHooks extends ServiceBuildHooks {}
}

export interface Options {
  env?: EnvironmentOptions;
  minify: boolean;

  /**
   * Determines how dependencies will be bundled into your application.
   * By default, Quilt will bundle all dev dependencies in your build
   * outputs, but will leave production dependencies and node built-in
   * modules as runtime dependencies. You can change this behavior by
   * passing `true`, which will force all dependencies to be bundled,
   * or by passing an object with granular controls on what dependencies
   * are bundled.
   */
  bundle?: boolean | RollupNodeBundle;
  format?: 'custom' | 'request-router';
}

const MAGIC_ENTRY_MODULE = '__quilt__/MagicEntryService.tsx';

export function serviceBuild({
  minify,
  bundle: explicitBundle,
  format = 'request-router',
  env,
}: Options) {
  return createProjectPlugin({
    name: 'Quilt.Service.Build',
    build({project, hooks, configure, run}) {
      hooks<ServiceBuildHooks>(({waterfall}) => ({
        quiltServiceOutputFormat: waterfall(),
      }));

      configure(
        (
          {
            outputDirectory,
            rollupInput,
            rollupPlugins,
            rollupOutputs,
            rollupNodeBundle,
            quiltServiceEntry,
            quiltServiceOutputFormat,
            quiltInlineEnvironmentVariables,
            quiltRuntimeEnvironmentVariables,
          },
          {quiltService = false},
        ) => {
          if (!quiltService) return;

          const inlineEnv = env?.inline;

          if (inlineEnv != null && inlineEnv.length > 0) {
            quiltInlineEnvironmentVariables?.((variables) =>
              Array.from(new Set([...variables, ...inlineEnv])),
            );
          }

          quiltRuntimeEnvironmentVariables?.(
            (runtime) => runtime ?? 'process.env',
          );

          // We want to force some of our “magic” modules to be internalized
          // no matter what, and other wise defer to the user-specified or
          // fallback behavior.
          rollupNodeBundle?.((defaultBundle) => {
            return addRollupNodeBundleInclusion(
              /@quilted[/]quilt[/](magic|env)/,
              explicitBundle ?? defaultBundle,
            );
          });

          rollupInput?.(async () => {
            return [MAGIC_ENTRY_MODULE];
          });

          rollupPlugins?.(async (plugins) => {
            const [{visualizer}] = await Promise.all([
              import('rollup-plugin-visualizer'),
            ]);

            plugins.unshift({
              name: '@quilted/magic-module-service',
              async resolveId(id, importer) {
                if (id !== MAGIC_ENTRY_MODULE) return null;

                return this.resolve(await quiltServiceEntry!.run(), importer, {
                  skipSelf: true,
                });
              },
            });

            if (minify) {
              const {minify} = await import('rollup-plugin-esbuild');
              plugins.push(minify());
            }

            plugins.push(
              visualizer({
                template: 'treemap',
                open: false,
                brotliSize: true,
                filename: project.fs.buildPath(
                  'reports',
                  `bundle-visualizer.html`,
                ),
              }),
            );

            return plugins;
          });

          rollupOutputs?.(async (outputs) => {
            const [format, outputRoot] = await Promise.all([
              quiltServiceOutputFormat!.run('module'),
              outputDirectory.run(project.fs.buildPath()),
            ]);

            outputs.push({
              format,
              entryFileNames: 'index.js',
              dir: path.join(outputRoot, 'runtime'),
            });

            return outputs;
          });
        },
      );

      run((step, {configuration}) =>
        step({
          name: 'Quilt.Service.Build',
          label: `Build service ${project.name}`,
          async run() {
            const [configure, {buildWithRollup}] = await Promise.all([
              configuration({
                quiltService: true,
                quiltRequestRouter: format === 'request-router',
              }),
              import('../tools/rollup'),
            ]);

            await rm(project.fs.buildPath('runtime'), {
              recursive: true,
              force: true,
            });

            await buildWithRollup(project, configure);
          },
        }),
      );
    },
  });
}
