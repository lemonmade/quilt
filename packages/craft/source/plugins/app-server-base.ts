import {stripIndent} from 'common-tags';

import {addRollupNodeBundleInclusion} from '../tools/rollup.ts';
import type {RollupNodeBundle} from '../tools/rollup.ts';

import {
  MAGIC_MODULE_BROWSER_ASSETS,
  MAGIC_MODULE_APP_COMPONENT,
} from '../constants.ts';
import {DiagnosticError, createProjectPlugin} from '../kit.ts';
import type {
  Project,
  ResolvedOptions,
  BuildProjectOptions,
  ResolvedBuildProjectConfigurationHooks,
  WaterfallHookWithDefault,
} from '../kit.ts';

import type {EnvironmentOptions} from './magic-module-env.ts';
import {resolveToActualFiles} from './app-base.ts';

export interface AppServerOptions {
  /**
   * The relative path to the module you want to use as the
   * entry for your app server. When provided, this completely
   * overwrites the default server content.
   *
   * @example './server.tsx'
   */
  entry?: string;

  /**
   * Whether this server code uses the `request-router` library to
   * define itself in a generic way, which can be adapted to a variety
   * of environments. By default, this is `'request-router'`, and when `'request-router'`,
   * the `entry` you specified must export an `RequestRouter` object as
   * its default export. When set to `false`, the app server will be built
   * as a basic server-side JavaScript project, without the special
   * `request-router` adaptor.
   *
   * @default 'request-router'
   */
  format?: 'request-router' | 'custom';

  /**
   * Whether the automatic server will serve assets for the browser build.
   * If this is `true`, you must ensure that your assets are stored in an
   * `assets` directory that is a sibling to the `server` directory that
   * will contain your server files. This is done automatically for you
   * with the default configuration applied by Quilt.
   *
   * @default true
   */
  serveAssets?: boolean;

  /**
   * Controls how the app server exposes environment variables.
   */
  env?: EnvironmentOptions;

  /**
   * Determines how dependencies will be bundled into your app server.
   * By default, Quilt will bundle all dev dependencies in your build
   * outputs, but will leave production dependencies and node built-in
   * modules as runtime dependencies. You can change this behavior by
   * passing `true`, which will force all dependencies to be bundled,
   * or by passing an object with granular controls on what dependencies
   * are bundled.
   */
  bundle?: boolean | RollupNodeBundle;
}

export interface AppServerConfigurationOptions {
  /**
   * Indicates that the app server build is being generated by Quilt.
   */
  quiltAppServer: boolean;
}

export interface AppServerBaseConfigurationHooks {
  /**
   * The module that acts as the entrypoint for this app.
   */
  readonly quiltAppServerEntry: WaterfallHookWithDefault<string>;
}

declare module '@quilted/sewing-kit' {
  interface BuildProjectOptions extends AppServerConfigurationOptions {}
  interface DevelopProjectOptions extends AppServerConfigurationOptions {}

  interface BuildProjectConfigurationHooks
    extends AppServerBaseConfigurationHooks {}
  interface DevelopProjectConfigurationHooks
    extends AppServerBaseConfigurationHooks {}
}

const MAGIC_SERVER_ENTRY_MODULE = '__quilt__/CustomAppServer.tsx';

export function appServer(options?: AppServerOptions) {
  return createProjectPlugin({
    name: 'Quilt.App.Server',
    build({project, hooks, configure}) {
      hooks<AppServerBaseConfigurationHooks>(({waterfall}) => ({
        quiltAppServerEntry: waterfall({
          default: () => getEntryForProject(project, options?.entry),
        }),
      }));

      configure(setupConfiguration(project, options));
    },
    develop({project, hooks, configure}) {
      hooks<AppServerBaseConfigurationHooks>(({waterfall}) => ({
        quiltAppServerEntry: waterfall({
          default: () => getEntryForProject(project, options?.entry),
        }),
      }));

      configure(setupConfiguration(project, options) as any);
    },
  });
}

function setupConfiguration(
  project: Project,
  {
    env,
    entry,
    format = 'request-router',
    bundle: explicitBundle,
  }: AppServerOptions = {},
) {
  const requestRouter = format === 'request-router';
  const inlineEnv = env?.inline;

  return (
    {
      runtimes,
      postcssPlugins,
      postcssProcessOptions,
      postcssCSSModulesOptions,
      rollupInput,
      rollupPlugins,
      rollupNodeBundle,
      quiltAppServerEntry,
      quiltAppServerEntryContent,
      quiltRequestRouterContent,
      quiltAsyncPreload,
      quiltAssetManifest,
      quiltInlineEnvironmentVariables,
      quiltRuntimeEnvironmentVariables,
    }: ResolvedBuildProjectConfigurationHooks,
    {quiltAppServer = false}: ResolvedOptions<BuildProjectOptions>,
  ) => {
    if (!quiltAppServer) return;

    if (inlineEnv != null && inlineEnv.length > 0) {
      quiltInlineEnvironmentVariables?.((variables) =>
        Array.from(new Set([...variables, ...inlineEnv])),
      );
    }

    quiltRuntimeEnvironmentVariables?.((runtime) => runtime ?? 'process.env');

    runtimes(() => [{target: 'node'}]);

    const content = entry
      ? requestRouter
        ? stripIndent`
          export {default} from ${JSON.stringify(
            project.fs.resolvePath(entry),
          )};
        `
        : stripIndent`
          import ${JSON.stringify(project.fs.resolvePath(entry))};
        `
      : stripIndent`
        import '@quilted/quilt/globals';
        import {jsx} from 'react/jsx-runtime';
        import App from ${JSON.stringify(MAGIC_MODULE_APP_COMPONENT)};
        import {RequestRouter} from ${JSON.stringify(
          MAGIC_MODULE_BROWSER_ASSETS,
        )};
        import {renderToResponse} from '@quilted/quilt/server';

        const router = new RequestRouter();
        const assets = new BrowserAssets();
        
        // For all GET requests, render our React application.
        router.get(async (request) => {
          const response = await renderToResponse(jsx(App), {
            request,
            assets,
          });
        
          return response;
        });
        
        export default router;
      `;

    quiltAsyncPreload?.(() => false);
    quiltAssetManifest?.(() => false);

    // We want to force some of our “magic” modules to be internalized
    // no matter what, and other wise defer to the user-specified or
    // fallback behavior.
    rollupNodeBundle?.((defaultBundle) => {
      return addRollupNodeBundleInclusion(
        /@quilted[/]quilt[/](magic|env)/,
        explicitBundle ?? defaultBundle,
      );
    });

    rollupPlugins?.(async (plugins) => {
      const {cssRollupPlugin} = await import('./rollup/css.ts');

      plugins.push(
        cssRollupPlugin({
          extract: false,
          postcssPlugins: () => postcssPlugins!.run(),
          postcssProcessOptions: () => postcssProcessOptions!.run(),
          postcssCSSModulesOptions: (options) =>
            postcssCSSModulesOptions!.run(options),
        }),
      );

      plugins.unshift({
        name: '@quilted/magic-module-app-server',
        async resolveId(id, importer) {
          if (id !== MAGIC_SERVER_ENTRY_MODULE) return null;

          return this.resolve(await quiltAppServerEntry!.run(), importer, {
            skipSelf: true,
          });
        },
      });

      return plugins;
    });

    if (requestRouter) {
      quiltRequestRouterContent?.(
        async () => await quiltAppServerEntryContent!.run(content),
      );
    } else {
      rollupInput?.(() => [MAGIC_SERVER_ENTRY_MODULE]);
    }
  };
}

const ENTRY_EXTENSIONS = ['mjs', 'js', 'jsx', 'ts', 'tsx'];

async function getEntryForProject(project: Project, explicitEntry?: string) {
  if (explicitEntry) {
    const [found] = await resolveToActualFiles(explicitEntry, project);

    if (found == null) {
      throw new DiagnosticError({
        title: `Could not find server entry for app ${project.name}`,
        suggestion: `The \`server.entry\` option ${JSON.stringify(
          explicitEntry,
        )} did not resolve to any files.`,
      });
    }

    return found;
  }

  const main = project.packageJson?.raw.main;

  if (typeof main === 'string') return project.fs.resolvePath(main);

  const [entry] = await project.fs.glob(
    `{server,service,backend}.{${ENTRY_EXTENSIONS.join(',')}}`,
    {
      absolute: true,
    },
  );

  if (entry == null) {
    throw new DiagnosticError({
      title: `Could not find entry for app ${project.name}`,
      suggestion: `Add the \`entry\` option to the \`quiltApp()\` call in its \`quilt.project.ts\` file. This option should point to a file that exports your main React component as the default export. Alternatively, you can set the path to this file as the "main" property in the app’s package.json file.`,
    });
  }

  return entry;
}
