import type {RollupNodeBundle} from '../tools/rollup.ts';

import {DiagnosticError, createProjectPlugin} from '../kit.ts';
import type {
  Project,
  Workspace,
  ResolvedOptions,
  BuildProjectOptions,
  ResolvedBuildProjectConfigurationHooks,
  WaterfallHookWithDefault,
} from '../kit.ts';

import type {EnvironmentOptions} from './magic-module-env.ts';
import {resolveToActualFiles} from './app-base.ts';

export interface AppServerOptions {
  /**
   * The relative path to the module you want to use as the
   * entry for your app server. When provided, this completely
   * overwrites the default server content.
   *
   * @example './server.tsx'
   */
  entry?: string;

  /**
   * Whether this server code uses the `request-router` library to
   * define itself in a generic way, which can be adapted to a variety
   * of environments. By default, this is `'request-router'`, and when `'request-router'`,
   * the `entry` you specified must export an `RequestRouter` object as
   * its default export. When set to `false`, the app server will be built
   * as a basic server-side JavaScript project, without the special
   * `request-router` adaptor.
   *
   * @default 'request-router'
   */
  format?: 'request-router' | 'custom';

  /**
   * Whether the automatic server will serve assets for the browser build.
   * If this is `true`, you must ensure that your assets are stored in an
   * `assets` directory that is a sibling to the `server` directory that
   * will contain your server files. This is done automatically for you
   * with the default configuration applied by Quilt.
   *
   * @default true
   */
  serveAssets?: boolean;

  /**
   * Controls how the app server exposes environment variables.
   */
  env?: EnvironmentOptions;

  /**
   * Determines how dependencies will be bundled into your app server.
   * By default, Quilt will bundle all dev dependencies in your build
   * outputs, but will leave production dependencies and node built-in
   * modules as runtime dependencies. You can change this behavior by
   * passing `true`, which will force all dependencies to be bundled,
   * or by passing an object with granular controls on what dependencies
   * are bundled.
   */
  bundle?: boolean | RollupNodeBundle;
}

export interface AppServerConfigurationOptions {
  /**
   * Indicates that the app server build is being generated by Quilt.
   */
  quiltAppServer: boolean;
}

export interface AppServerBaseConfigurationHooks {
  /**
   * The module that acts as the entrypoint for this app.
   */
  readonly quiltAppServerEntry: WaterfallHookWithDefault<string>;
}

declare module '@quilted/sewing-kit' {
  interface BuildProjectOptions extends AppServerConfigurationOptions {}
  interface DevelopProjectOptions extends AppServerConfigurationOptions {}

  interface BuildProjectConfigurationHooks
    extends AppServerBaseConfigurationHooks {}
  interface DevelopProjectConfigurationHooks
    extends AppServerBaseConfigurationHooks {}
}

export function appServer(options?: AppServerOptions) {
  return createProjectPlugin({
    name: 'Quilt.App.Server',
    build({project, workspace, hooks, configure}) {
      hooks<AppServerBaseConfigurationHooks>(({waterfall}) => ({
        quiltAppServerEntry: waterfall({
          default: () => getEntryForProject(project, options?.entry),
        }),
      }));

      configure(
        setupConfiguration(project, workspace, {
          ...options,
          mode: 'production',
        }),
      );
    },
    develop({project, workspace, hooks, configure}) {
      hooks<AppServerBaseConfigurationHooks>(({waterfall}) => ({
        quiltAppServerEntry: waterfall({
          default: () => getEntryForProject(project, options?.entry),
        }),
      }));

      configure(
        setupConfiguration(project, workspace, {
          ...options,
          mode: 'development',
        }) as any,
      );
    },
  });
}

function setupConfiguration(
  project: Project,
  workspace: Workspace,
  {
    mode,
    env,
    entry,
    format = 'request-router',
    bundle: explicitBundle,
  }: AppServerOptions & {mode: 'production' | 'development'},
) {
  const requestRouter = format === 'request-router';

  return (
    {
      runtimes,
      postcssPlugins,
      postcssProcessOptions,
      postcssCSSModulesOptions,
      rollupInput,
      rollupPlugins,
      rollupNodeBundle,
      quiltAppServerEntry,
      quiltAppServerEntryContent,
      quiltAsyncPreload,
      quiltAssetManifest,
      quiltEnvModuleContent,
      quiltInlineEnvironmentVariables,
      quiltRuntimeEnvironmentVariables,
    }: ResolvedBuildProjectConfigurationHooks,
    {quiltAppServer = false}: ResolvedOptions<BuildProjectOptions>,
  ) => {
    if (!quiltAppServer) return;

    // rollupNodeBundle?

    runtimes(() => [{target: 'node'}]);

    quiltAsyncPreload?.(() => false);
    quiltAssetManifest?.(() => false);

    rollupNodeBundle?.((defaultBundle) => explicitBundle ?? defaultBundle);

    rollupPlugins?.(async (plugins) => {
      const [{cssRollupPlugin}, {appMagicModules}] = await Promise.all([
        import('./rollup/css.ts'),
        import('../tools/rollup/app.ts'),
      ]);

      return [
        appMagicModules({
          mode,
          env: {
            dotenv: {roots: [project.fs.root, workspace.fs.root]},
            inline: () =>
              quiltInlineEnvironmentVariables?.run(env?.inline ?? []),
            runtime: () => quiltRuntimeEnvironmentVariables?.run('process.env'),
            customize: (content) =>
              quiltEnvModuleContent?.run(content) ?? content,
          },
          server: entry ?? {
            customize: (content) =>
              quiltAppServerEntryContent?.run(content) ?? content,
          },
          browser: false,
        }),
        ...plugins,
        cssRollupPlugin({
          extract: false,
          postcssPlugins: () => postcssPlugins!.run(),
          postcssProcessOptions: () => postcssProcessOptions!.run(),
          postcssCSSModulesOptions: (options) =>
            postcssCSSModulesOptions!.run(options),
        }),
      ];
    });

    if (!requestRouter) {
      rollupInput?.(async () => [await quiltAppServerEntry!.run()]);
    }
  };
}

const ENTRY_EXTENSIONS = ['mjs', 'js', 'jsx', 'ts', 'tsx'];

async function getEntryForProject(project: Project, explicitEntry?: string) {
  if (explicitEntry) {
    const [found] = await resolveToActualFiles(explicitEntry, project);

    if (found == null) {
      throw new DiagnosticError({
        title: `Could not find server entry for app ${project.name}`,
        suggestion: `The \`server.entry\` option ${JSON.stringify(
          explicitEntry,
        )} did not resolve to any files.`,
      });
    }

    return found;
  }

  const main = project.packageJson?.raw.main;

  if (typeof main === 'string') return project.fs.resolvePath(main);

  const [entry] = await project.fs.glob(
    `{server,service,backend}.{${ENTRY_EXTENSIONS.join(',')}}`,
    {
      absolute: true,
    },
  );

  if (entry == null) {
    throw new DiagnosticError({
      title: `Could not find entry for app ${project.name}`,
      suggestion: `Add the \`entry\` option to the \`quiltApp()\` call in its \`quilt.project.ts\` file. This option should point to a file that exports your main React component as the default export. Alternatively, you can set the path to this file as the "main" property in the appâ€™s package.json file.`,
    });
  }

  return entry;
}
